using csly.models;

namespace sourceGenerationTester.expressionParser;

[ParserGenerator]
public partial class Expression : AbstractParserGenerator<ExpressionToken, ExpressionParser, double>
{

}

   [ParserRoot("expression")]
    public class ExpressionParser
    {
        [Production("primary: INT")]
        public int Primaryint(Token<ExpressionToken> dbl) => dbl.IntValue;

        [Production("primary: TEN")]
        public int PrimaryPi(Token<ExpressionToken> pi)
        {
            return 10;
        }

        [Production("primary: FORTYTWO")]
        public int PrimaryE(Token<ExpressionToken> e)
        {
            return 42;
        }

        [NodeName("group")]
        [Production("primary: LPAREN  expression RPAREN ")]
        public int Group(Token<ExpressionToken> l, int groupValue, Token<ExpressionToken> r)
        {
            return groupValue;
        }


        [NodeName("addOrSubstract")]
        [Production("expression : term PLUS expression")]
        [Production("expression : term MINUS expression")]
        public int Expression(int left, Token<ExpressionToken> operatorToken, int right)
        {
            int result = 0;


            switch (operatorToken.TokenID)
            {
                case ExpressionToken.PLUS:
                    {
                        result = left + right;
                        break;
                    }
                case ExpressionToken.MINUS:
                    {
                        result = left - right;
                        break;
                    }
            }

            return result;
        }


        [NodeName("expression")]
        [Production("expression : term")]
        public int Expression_Term(int termValue)
        {
            return termValue;
        }

        [NodeName("multOrDivide")]
        [Production("term : factor TIMES term")]
        [Production("term : factor DIVIDE term")]
        [Production("term : factor EXP term")]
        public int Term(int left, Token<ExpressionToken> operatorToken, int right)
        {
            int result = 0;


            switch (operatorToken.TokenID)
            {
                case ExpressionToken.TIMES:
                    {
                        result = left * right;
                        break;
                    }
                case ExpressionToken.DIVIDE:
                    {
                        result = left / right;
                        break;
                    }
                case ExpressionToken.EXP:
                {
                    result = (int)Math.Pow(left, right);
                    break;
                }
            }

            return result;
        }

        [Production("term : factor")]
        [NodeName("term")]
        public int Term_Factor(int factorValue)
        {
            return factorValue;
        }

        [Production("factor : primary")]
        [NodeName("primary")]
        public int primaryFactor(int primValue)
        {
            return primValue;
        }

        [NodeName("negate")]
        [Production("factor : MINUS factor")]
        public int MinusFactor(Token<ExpressionToken> discardedMinus, int factorValue)
        {
            return -factorValue;
        }
    }


{
    public enum ExpressionToken
    {
        // float number 
        //[Double] DOUBLE = 1,

        // integer        
        [Int] INT = 3,

        [AlphaId] IDENTIFIER = 4,



        // the + operator
        [Sugar("+")] PLUS = 5,

        // the - operator
        [Sugar("-")] MINUS = 6,

        // the * operator
        [Sugar("*")] TIMES = 7,

        //  the  / operator
        [Sugar("/")] DIVIDE = 8,

        // a left paranthesis (
        [Sugar("(")] LPAREN = 9,

        // a right paranthesis )
        [Sugar(")")] RPAREN = 10,

        [Sugar("!")] FACTORIAL = 13,

        [Keyword("TEN")] TEN = 15,

        [Keyword("FORTYTWO")] FORTYTWO = 17,

        [Sugar("^^")] EXP = 18,

    }
}
