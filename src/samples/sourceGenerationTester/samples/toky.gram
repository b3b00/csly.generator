using csly.models;

namespace extending;

public enum Toky
{
    [AlphaId] ID,
    [Keyword("A")] A,
    [Keyword("AA")] AA,
    [Keyword("B")] B,
    [Keyword("C")] C,
    [Keyword("D")] D,
    [Keyword("X")] X,
    [Keyword("Y")] Y,
    [Keyword("Z")] Z,
    [Sugar("+")] PLUS,
    [Sugar("++")] INC,
    [Sugar("=")] ASSIGN,
    [Sugar("==")] EQUALS,
    [Int] INT,
    [Double] DOUBLE,
    [String] STRING_1,
    [String("'","\\")] STRING_2,
    [Push("brackets")]
    [Sugar(">")] GT,
    [Mode("brackets")]
    [Sugar(".")] DOT,
    [Pop()]
    [Sugar("<")] LT,
}


[ParserRoot("root")]
    public class ExtParser
    {

        [Production("root : a b")]
        public string Root(string a, string b)
        {
            return a + " " + b;
        }

        [Production("a : [A | AA ]")]
        public string A(Token<Toky> a)
        {
            return a.TokenID == Toky.A ? "ah ah" : "aah aah";
        }

        [Production("b : [b1 | b2]")]
        public string B(string b) => b;

        [Production("b1 : B")]
        public string B1(Token<Toky> b) => "🐝";
        
        [Production("b2 : D")]
        public string B2(Token<Toky> d) => "🦆";


        [Production("bs : B* D")]
        public string Bs(List<Token<Toky>> bs, Token<Toky> d)
        {
            string bees = bs.Count > 0 ? $"{bs.Count} 🐝" : "no 🐝";
            return $"{bees}, lady di";
        }

        [Production("c : C")]
        public string C(Token<Toky> c)
        {
            return "si!";
        }

        [Production("option : X? Y Z")]
        public string Option(Token<Toky> x, Token<Toky> y, Token<Toky> z)
        {
            string ex = x.IsEmpty ? "" : "ex ";
            return $"{ex}why zee";
        }
    }

[ParserGenerator]
public partial class Tokynou : AbstractParserGenerator<Toky, ExtParser, string>
{
}