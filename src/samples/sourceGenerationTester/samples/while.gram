using csly.whileLang.models;
using csly.whileLang.model;
using whileLang;

namespace whileLang;

[ParserGenerator]

public partial class While : AbstractParserGenerator<WhileTokenGeneric, WhileParserGeneric, WhileAST>
{

}

 public enum WhileTokenGeneric
    {
         #region keywords 0 -> 19

        [Lexeme(GenericToken.KeyWord, "IF")] [Lexeme(GenericToken.KeyWord, "if")]
        IF = 1,

        [Lexeme(GenericToken.KeyWord, "THEN")] [Lexeme(GenericToken.KeyWord, "then")]
        THEN = 2,

        [Lexeme(GenericToken.KeyWord, "ELSE")] [Lexeme(GenericToken.KeyWord, "else")]
        ELSE = 3,

        [Lexeme(GenericToken.KeyWord, "WHILE")] [Lexeme(GenericToken.KeyWord, "while")]
        WHILE = 4,

        [Lexeme(GenericToken.KeyWord, "DO")] [Lexeme(GenericToken.KeyWord, "do")]
        DO = 5,

        [Lexeme(GenericToken.KeyWord, "SKIP")] [Lexeme(GenericToken.KeyWord, "skip")]
        SKIP = 6,

        [Lexeme(GenericToken.KeyWord, "TRUE")] [Lexeme(GenericToken.KeyWord, "true")]
        TRUE = 7,

        [Lexeme(GenericToken.KeyWord, "FALSE")] [Lexeme(GenericToken.KeyWord, "false")]
        FALSE = 8,

        [Lexeme(GenericToken.KeyWord, "NOT")] [Lexeme(GenericToken.KeyWord, "not")]
        NOT = 9,

        [Lexeme(GenericToken.KeyWord, "AND")] [Lexeme(GenericToken.KeyWord, "and")]
        AND = 10,

        [Lexeme(GenericToken.KeyWord, "OR")] [Lexeme(GenericToken.KeyWord, "or")]
        OR = 11,

        [Lexeme(GenericToken.KeyWord, "PRINT")] [Lexeme(GenericToken.KeyWord, "print")]
        PRINT = 12,

        [Lexeme(GenericToken.KeyWord, "RETURN")] [Lexeme(GenericToken.KeyWord, "return")]
        RETURN = 13,

        #endregion

        #region literals 20 -> 29

        [Mode("default", "fstringExpression")]
        [Lexeme(GenericToken.Identifier, IdentifierType.AlphaNumericDash)]
        IDENTIFIER = 20,

        [Lexeme(GenericToken.Int)] INT = 22,

        #endregion

        #region operators 30 -> 49

        [Mode("default", "fstringExpression")]
        [Lexeme(GenericToken.SugarToken, ">")] GREATER = 30,

        [Mode("default", "fstringExpression")]
        [Lexeme(GenericToken.SugarToken, "<")] LESSER = 31,

        [Mode("default", "fstringExpression")]
        [Lexeme(GenericToken.SugarToken, "==")]
        EQUALS = 32,

        [Mode("default", "fstringExpression")]
        [Lexeme(GenericToken.SugarToken, "!=")]
        DIFFERENT = 33,

        [Mode("default", "fstringExpression")]
        [Lexeme(GenericToken.SugarToken, ".")] CONCAT = 34,

        
        [Lexeme(GenericToken.SugarToken, ":=")] ASSIGN = 35,

        [Mode("default", "fstringExpression")]
        [Lexeme(GenericToken.SugarToken, "+")] PLUS = 36,

        [Mode("default", "fstringExpression")]
        [Lexeme(GenericToken.SugarToken, "-")] MINUS = 37,

        [Mode("default", "fstringExpression")]
        [Lexeme(GenericToken.SugarToken, "*")] TIMES = 38,

        [Mode("default", "fstringExpression")]
        [Lexeme(GenericToken.SugarToken, "/")] DIVIDE = 39,
        
        [Mode("default","fstringExpression")]
        [Sugar("?")]
        QUESTION,
        
        [Mode("default","fstringExpression")]
        [Sugar("->")]
        ARROW,
        
        [Mode("default","fstringExpression")]
        [Sugar("(")]
        LPAREN,
        
        [Mode("default","fstringExpression")]
        [Sugar(")")]
        RPAREN,
        
        [Mode("default","fstringExpression")]
        [Sugar("|")]
        COLON,
        
        #endregion

        #region sugar 50 ->


        [Lexeme(GenericToken.SugarToken, ";")] SEMICOLON = 52,


        [SingleLineComment("#")] COMMENT = 1236,

        #endregion

        #region fstring 100 ->

        [Push("fstringExpression")] 
        [Mode("fstring")]
        [Sugar("{")]
        OPEN_FSTRING_EXPPRESSION = 100,

        [Pop] 
        [Mode("fstringExpression")] 
        [Sugar("}")]
        CLOSE_FSTRING_EXPPRESSION = 101,

        [Sugar("$\"")]
        [Mode("default", "fstringExpression")]
        [Push("fstring")] 
        OPEN_FSTRING,

        [Sugar("\"")] 
        [Mode("fstring", "fstringExpression")]
        [Pop]  
        CLOSE_FSTRING,

        
        [Mode("fstring")]
        [UpTo("{","\"")]
        FSTRING_CONTENT,
        
        #endregion




    }

[ParserRoot("statement")]
    public class WhileParserGeneric
    {

    public BinaryOperation BuildConcat(List<Expression> operands)
        {
            if (operands.Count == 1)
            {
                var operation = new BinaryOperation(operands[0], BinaryOperator.CONCAT, new StringConstant("",null));
                return operation;
            }
            else if (operands.Count == 2)
            {
                var operation = new BinaryOperation(operands[0], BinaryOperator.CONCAT, operands[1]);
                return operation;
            }
            else if (operands.Count > 2)
            {
                var right = BuildConcat(operands.Skip(1).ToList());
                var operation = new BinaryOperation(operands[0], BinaryOperator.CONCAT, right);
                return operation;
            }

            return null;
        }

        #region COMPARISON OPERATIONS

        [Operation((int) WhileTokenGeneric.LESSER, Affix.InFix, Associativity.Right, 50)]
        [Operation((int) WhileTokenGeneric.GREATER, Affix.InFix, Associativity.Right, 50)]
        [Operation((int) WhileTokenGeneric.EQUALS, Affix.InFix, Associativity.Right, 50)]
        [Operation((int) WhileTokenGeneric.DIFFERENT, Affix.InFix, Associativity.Right, 50)]
        public WhileAST binaryComparisonExpression(WhileAST left, Token<WhileTokenGeneric> operatorToken,
            WhileAST right)
        {
            var oper = BinaryOperator.ADD;

            switch (operatorToken.TokenID)
            {
                case WhileTokenGeneric.LESSER:
                {
                    oper = BinaryOperator.LESSER;
                    break;
                }
                case WhileTokenGeneric.GREATER:
                {
                    oper = BinaryOperator.GREATER;
                    break;
                }
                case WhileTokenGeneric.EQUALS:
                {
                    oper = BinaryOperator.EQUALS;
                    break;
                }
                case WhileTokenGeneric.DIFFERENT:
                {
                    oper = BinaryOperator.DIFFERENT;
                    break;
                }
            }

            var operation = new BinaryOperation(left as Expression, oper, right as Expression);
            return operation;
        }

        #endregion

        #region STRING OPERATIONS

        [Operation((int) WhileTokenGeneric.CONCAT, Affix.InFix, Associativity.Right, 10)]
        public WhileAST binaryStringExpression(WhileAST left, Token<WhileTokenGeneric> operatorToken, WhileAST right)
        {
            var oper = BinaryOperator.CONCAT;
            var operation = new BinaryOperation(left as Expression, oper, right as Expression);
            return operation;
        }

        #endregion

        #region statements

        [Production("statement :  LPAREN[d] statement RPAREN[d] ")]
        public WhileAST block(WhileAST statement)
        {
            return statement;
        }

        [Production("statement : sequence")]
        public WhileAST statementSequence(WhileAST sequence)
        {
            return sequence;
        }

        [Production("sequence : statementPrim additionalStatements*")]
        public WhileAST sequenceStatements(WhileAST first, List<WhileAST> next)
        {
            var seq = new SequenceStatement(first as Statement);
            seq.AddRange(next.Cast<Statement>().ToList());
            return seq;
        }

        [Production("additionalStatements : SEMICOLON[d] statementPrim")]
        public WhileAST additional(WhileAST statement)
        {
            return statement;
        }

        [Production("statementPrim: IF[d] WhileParserGeneric_expressions THEN[d] statement ELSE[d] statement")]
        public WhileAST ifStmt(WhileAST cond, WhileAST thenStmt, WhileAST elseStmt)
        {
            var stmt = new IfStatement(cond as Expression, thenStmt as Statement, elseStmt as Statement);
            return stmt;
        }

        [Production("statementPrim: WHILE[d] WhileParserGeneric_expressions DO[d] statement")]
        public WhileAST whileStmt(WhileAST cond, WhileAST blockStmt)
        {
            var stmt = new WhileStatement(cond as Expression, blockStmt as Statement);
            return stmt;
        }

        [Production("statementPrim: IDENTIFIER ASSIGN[d] WhileParserGeneric_expressions")]
        public WhileAST assignStmt(Token<WhileTokenGeneric> variable, WhileAST value)
        {
            var assign = new AssignStatement(variable.StringWithoutQuotes, value as Expression);
            return assign;
        }

        [Production("statementPrim: SKIP[d]")]
        public WhileAST skipStmt()
        {
            return new SkipStatement();
        }

        [Production("statementPrim: PRINT[d] WhileParserGeneric_expressions")]
        public WhileAST skipStmt(WhileAST expression)
        {
            return new PrintStatement(expression as Expression);
        }

        #endregion


        #region OPERANDS

        [Production("primary: INT")]
        public WhileAST PrimaryInt(Token<WhileTokenGeneric> intToken)
        {
            return new IntegerConstant(intToken.IntValue);
        }

        [Production("primary: [TRUE|FALSE]")]        
        public WhileAST PrimaryBool(Token<WhileTokenGeneric> boolToken)
        {
            return new BoolConstant(bool.Parse(boolToken.StringWithoutQuotes));
        }

        [Production("primary: fstring")]
        public WhileAST PrimaryString(WhileAST stringToken)
        {
            return stringToken;
        }

        [Production("primary: IDENTIFIER")]
        public WhileAST PrimaryId(Token<WhileTokenGeneric> varToken)
        {
            return new Variable(varToken.StringWithoutQuotes);
        }

        
        [Production("primary: LPAREN[d] WhileParserGeneric_expressions RPAREN[d] ")]
        public WhileAST PrimaryGroup(WhileAST expression    )
        {
            return expression;
        }

        [Operand]
        [Production("operand: primary")]
        public WhileAST Operand(WhileAST prim)
        {
            return prim;
        }

        #endregion

        #region NUMERIC OPERATIONS

        [Operation((int) WhileTokenGeneric.PLUS, Affix.InFix, Associativity.Right, 10)]
        [Operation((int) WhileTokenGeneric.MINUS, Affix.InFix, Associativity.Right, 10)]
        public WhileAST binaryTermNumericExpression(WhileAST left, Token<WhileTokenGeneric> operatorToken,
            WhileAST right)
        {
            var oper = BinaryOperator.ADD;

            switch (operatorToken.TokenID)
            {
                case WhileTokenGeneric.PLUS:
                {
                    oper = BinaryOperator.ADD;
                    break;
                }
                case WhileTokenGeneric.MINUS:
                {
                    oper = BinaryOperator.SUB;
                    break;
                }
            }

            var operation = new BinaryOperation(left as Expression, oper, right as Expression);
            return operation;
        }

        [Operation((int) WhileTokenGeneric.TIMES, Affix.InFix, Associativity.Right, 50)]
        [Operation((int) WhileTokenGeneric.DIVIDE, Affix.InFix, Associativity.Right, 50)]
        public WhileAST binaryFactorNumericExpression(WhileAST left, Token<WhileTokenGeneric> operatorToken,
            WhileAST right)
        {
            var oper = BinaryOperator.MULTIPLY;

            switch (operatorToken.TokenID)
            {
                case WhileTokenGeneric.TIMES:
                {
                    oper = BinaryOperator.MULTIPLY;
                    break;
                }
                case WhileTokenGeneric.DIVIDE:
                {
                    oper = BinaryOperator.DIVIDE;
                    break;
                }
            }

            var operation = new BinaryOperation(left as Expression, oper, right as Expression);
            return operation;
        }

        [Operation((int) WhileTokenGeneric.MINUS, Affix.PreFix, Associativity.Right, 100)]
        public WhileAST unaryNumericExpression(Token<WhileTokenGeneric> operation, WhileAST value)
        {
            return new Neg(value as Expression);
        }

        #endregion


        #region BOOLEAN OPERATIONS

        [Operation((int) WhileTokenGeneric.OR, Affix.InFix, Associativity.Right, 10)]
        public WhileAST binaryOrExpression(WhileAST left, Token<WhileTokenGeneric> operatorToken, WhileAST right)
        {
            var oper = BinaryOperator.OR;


            var operation = new BinaryOperation(left as Expression, oper, right as Expression);
            return operation;
        }

        [Operation((int) WhileTokenGeneric.AND, Affix.InFix, Associativity.Right, 50)]
        public WhileAST binaryAndExpression(WhileAST left, Token<WhileTokenGeneric> operatorToken, WhileAST right)
        {
            var oper = BinaryOperator.AND;


            var operation = new BinaryOperation(left as Expression, oper, right as Expression);
            return operation;
        }

        [Operation((int) WhileTokenGeneric.NOT, Affix.PreFix, Associativity.Right, 100)]
        public WhileAST binaryOrExpression(Token<WhileTokenGeneric> operatorToken, WhileAST value)
        {
            return new Not(value as Expression);
        }

        #endregion

        #region fstrings

        [Operand]
        // fstrings 
        [Production("fstring : OPEN_FSTRING[d] fstring_element* CLOSE_FSTRING[d]")]
        public WhileAST fstring(List<WhileAST> elements)
        {
            if (elements.Count == 1)
            {
                return elements[0];
            }
            return BuildConcat(elements.Cast<Expression>().ToList());
        }

        [Production("fstring_element : FSTRING_CONTENT")]
        public WhileAST FStringContent(Token<WhileTokenGeneric> element)
        {
            return new StringConstant(element.Value,element.Position);
        }
        
        [Production("fstring_element : OPEN_FSTRING_EXPPRESSION[d] WhileParserGeneric_expressions CLOSE_FSTRING_EXPPRESSION[d]")]
        public WhileAST FStringExpression(WhileAST expression)
        {
            return expression;
        }

        #endregion
    }
