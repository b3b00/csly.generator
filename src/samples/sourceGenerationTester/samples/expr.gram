using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using csly.models;

namespace expr;


    public enum ExprToken
    {
        [Sugar("+")] PLUS,
        [Sugar("-")] MINUS,
        [Sugar("*")] TIMES,
        [Sugar("/")] DIV,
        [Int] INT,
        [Sugar("(")] LPAREN,
        [Sugar(")")] RPAREN,
        [Sugar("!")] FACTORIAL,

        [Sugar(";")] SEMICOLON,
        [Sugar("=")] ASSIGN,
        [Sugar(",")] COMMA,

        [AlphaNumId] ID,
        [Keyword("PRINT")] PRINT,
        [Keyword("TEST")] TEST,
        [Keyword("TRUE")] T,
        [Keyword("FALSE")] F,




    }

    [ParserRoot("root")]
    public class ExprParser
    {

Dictionary<string, int> variables = new Dictionary<string, int>();

[Production("root : statement*")]
        public int root(List<int> statements)
        {
            return statements.Sum();
        }

        [Production("statement : [test|print]")]
        public int statement_assign(int statement)
        {
            return statement;
        }

        


[Production("test : TEST LPAREN ID COMMA ExprParser_expressions COMMA INT COMMA [T|F]  RPAREN SEMICOLON")]
        public int test(Token<ExprToken> test, Token<ExprToken> lp, Token<ExprToken> id, Token<ExprToken> comma1, int expr, Token<ExprToken> comma2, Token<ExprToken> expected, Token<ExprToken> comma3, Token<ExprToken> neg, Token<ExprToken> rp, Token<ExprToken> semi)
        {
            int expectedValue = expected.IntValue;
            bool isNegated = neg.TokenID == ExprToken.T;
            expectedValue = isNegated ?  -expectedValue : expectedValue;
            
            if (expr != expectedValue)
            {
                Console.WriteLine($"\x1b[31mTEST FAILED for variable {id.Value}: got {expr} but was expecting {expectedValue}\x1b[0m");
            }
            else
            {
                Console.WriteLine($"\x1b[32mTEST SUCCEEDED for variable {id.Value}: got expected value {expectedValue}\x1b[0m");
            }
        
            variables[id.Value] = expr;

            return expr;
        }

        



        [Production("print : PRINT ID SEMICOLON")]
        public int print(Token<ExprToken> printTok, Token<ExprToken> id, Token<ExprToken> semi)
        {
            if (variables.TryGetValue(id.Value, out int value))
            {
                Console.WriteLine($"PRINT: {id.Value} = {value}");
            }
            else
            {
                Console.WriteLine($"\x1b[31mERROR: variable {id.Value} is not defined.\x1b[0m");
            }
            return 0;
        }

    #region  Expressions


    [Operation("PLUS",Affix.InFix,Associativity.Left,10)]
        public int Plus(int left, Token<ExprToken> op, int right)
        {
            return left + right;
        }

        [Operation("MINUS", Affix.InFix, Associativity.Left, 10)]
        public int Minus(int left, Token<ExprToken> op, int right)
        {
            return left - right;
        }

        [Right("TIMES",50)]
        public int Times(int left, Token<ExprToken> op, int right)
        {
            return left * right;
        }

        [Right("DIV",50)]
        public int Divide(int left, Token<ExprToken> op, int right)
        {
            return left / right;
        }
        
        [Prefix("MINUS",Associativity.Left,100)]
        public int UMinus(Token<ExprToken> op, int right)
        {
            return -right;
        }
        
        [Postfix("FACTORIAL", Associativity.Left, 110)]
    public int Factorial(int value, Token<ExprToken> op)
    {
        int factorial = 1;
        for (int i = value ; i > 1; i--)
        {
            factorial *= i;
        }
        return factorial;
    }


        [Operand]
        [Production("intOperand : INT")]
        public int intOperand(Token<ExprToken> intToken)
        {
            return intToken.IntValue;
        }

        [Operand]
        [Production("parenthesizedOperand : LPAREN ExprParser_expressions RPAREN")]
        public int parenthesizedOperand(Token<ExprToken> lp, int expr, Token<ExprToken> rp)
        {
            return expr;
        }

        #endregion

    }

    [ParserGenerator]
    public class Expr : AbstractParserGenerator<ExprToken, ExprParser, int>
    {
    }

